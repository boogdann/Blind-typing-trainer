unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;

type
  TfmMainLogic = class(TForm)
    memoStringOutput: TMemo;
    edtStringFromUser: TEdit;
    procedure edtStringFromUserKeyPress(Sender: TObject; var Key: Char);
    procedure FormCreate(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  fmMainLogic: TfmMainLogic;
Var
  UserString: string;
  RandomString: String = 'qwertyu asdf';
  MaxLength: Integer = 20;
  TempForDuplicate: Integer = 2;
  PosUserStr, PosRandomStr, j, k: Integer;
  UserPart, RandomPart: string;
  OutputString: string;
  MinLength: Integer;
  MainLengthUserStr: Integer;
  kolElementsUserStr: Integer = 0;
  kolElementsRandomStr: INteger = 0;
implementation

{$R *.dfm}

procedure TfmMainLogic.edtStringFromUserKeyPress(Sender: TObject; var Key: Char);
var
  i: Integer;
begin
  if not (Key in ['a'..'z', 'A'..'Z' ,#13, '1', '3', ' ']) then
    Key := #0;

  UserString := edtStringFromUser.Text;
  MainLengthUserStr := Length(UserString);
  SetLength(UserString, Length(RandomString));

  if (Key = #13) then
  begin
    // ShowMessage('WORKK!!!');
    if (UserString = RandomString) then
    begin
      // рандом новго слова
    end;

    if (Length(UserString) <= Length(RandomString)) then
      MaxLength := Length(RandomString)
    else
      MaxLength := Length(UserString);

    PosUserStr := 0;
    PosRandomStr := 0;

    i := 1;
    while (i <= Length(RandomString)) do
    begin
      while ((UserString[PosUserStr] <> ' ') and (PosUserStr <= MainLengthUserStr)) do
      begin
        Inc(PosUserStr);
        Inc(kolElementsUserStr);
      end;

      while ((RandomString[PosRandomStr] <> ' ') and (PosRandomStr <= Length(RandomString))) do
      begin
        Inc(PosRandomStr);
        INc(kolElementsRandomStr);
      end;

      UserPart := Copy(UserString, i, kolElementsUserStr);
      RandomPart := Copy(RandomString, i, kolElementsRandomStr);

      if (UserPart = RandomPart) then
      begin
        // OutputString := OutputString +
        // брать из файли слово на -2 буквы
      end
      else
      begin

        j := 1;
        while ((j <= Length(RandomPart)) and (UserPart[i] <> ' ')) do
        begin
          if (UserPart[j] <> RandomPart[j]) then
          begin
            for k := 1 to TempForDuplicate div 2 do
              OutputString := OutputString + RandomPart[j];
          end;
            OutputString := OutputString + RandomPart[j];
          Inc(j);
        end;
      end;



//        if (Length(UserPart) >= Length(RandomPart)) then
//        begin
//
//          j := 1;
//          while (j <= Length(RandomPart)) do
//          begin
//            if (UserPart[j] <> RandomPart[j]) then
//            begin
//              for k := 1 to TempForDuplicate div 2 do
//                OutputString := OutputString + RandomPart[j];
//            end;
//            OutputString := OutputString + RandomPart[j];
//            Inc(j);
//          end;
//
//          j := Length(RandomPart) + 1;
//          while (j <= Length(UserPart)) do
//            for k := 1 to TempForDuplicate div 2 do
//              OutputString := OutputString + RandomPart[j];
//
//        end
//        else
//        begin
//
//          j := 1;
//          while (j <= Length(UserPart)) do
//          begin
//            if (UserPart[j] <> RandomPart[j]) then
//            begin
//              for k := 1 to TempForDuplicate div 2 do
//                OutputString := OutputString + RandomPart[j];
//            end;
//
//            OutputString := OutputString + RandomPart[j];
//            Inc(j);
//          end;
//
//          j := Length(RandomPart) + 1;
//          while (j <= Length(RandomPart)) do
//            for k := 1 to TempForDuplicate div 2 do
//              OutputString := OutputString + UserPart[j];
//        end

//      end;

      PosUserStr := PosRandomStr;
      i := PosUserStr;


      memoStringOutput.Lines[0] := OutputString;
      edtStringFromUser.Clear;
    end;
    memoStringOutput.Clear;
    memoStringOutput.Lines[0] := OutputString;
  end;
    // memoStringOutput.Clear;
    // memoStringOutput.Lines[0] := RandomString;

    if (Length(UserString) >= 60) then
    begin
      ShowMessage('Игра проиграна. Попробуйте ещё');
      // начало игры заново !!!!!!!!!!!!!!!!!!!!!!!!!!!1
    end;
    Inc(i);

   // memoStringOutput.Lines[0] := UserString;



end;

procedure TfmMainLogic.FormCreate(Sender: TObject);
begin
  memoStringOutput.Lines[0] := RandomString;
end;

end.


